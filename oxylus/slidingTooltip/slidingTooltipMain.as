package oxylus.slidingTooltip {	import caurina.transitions.*;	import caurina.transitions.properties.FilterShortcuts;		import flash.display.*;	import flash.filters.DropShadowFilter;	import flash.filters.BlurFilter;	import flash.utils.Timer;	import flash.utils.getDefinitionByName;	import flash.text.*;	import flash.events.*;	import flash.geom.Matrix;		public class slidingTooltipMain extends MovieClip {		//private var content:MovieClip;		//private var tip_mask:MovieClip;				private var bg:MovieClip;		private var stroke:MovieClip;		private var graf:MovieClip;				private var Text:MovieClip;				private var obj:Object;		private var currentPos:Number;				private var myTimer:Timer;				private var actualBgWidth:Number;		private var actualBgHeight:Number;				private var bgX:Number = 0;		private var bgY:Number = 0;				private var maskWN:Number;		private var maskHN:Number;		private var maskWO:Number;		private var maskHO:Number;		private var maskXN:Number = 0;		private var maskXO:Number = 0;		private var maskYN:Number = 0;		private var maskYO:Number = 0;				public var target:Sprite;		public var container:DisplayObjectContainer;			public function slidingTooltipMain() {			FilterShortcuts.init();						this.alpha = 0;			this.x = 1000;			this.y = 1000;			Text = new MovieClip();			content.addChild(Text);			stroke = content["stroke"];			bg = content["bg"];			graf = content["graf"];			}					/**		 * This function will attach the tooltip.		 * It will create a random instance name and it will attach the tooltip on the stage		 * at the highest free depth found		 * @return		 */		public function attach(aContainer:DisplayObjectContainer, aTarget:Sprite):void {			container = aContainer;			container.addChild(this);			target = aTarget;		}				public function getTip():String {			return obj.Text;		}				public function getOrientation():String {			return (obj.tipOrientationX + obj.tipOrientationY);		}						public function destroy():void {			if (myTimer) {				myTimer.stop();			}		}										/**		 * In this function you can setup your own default values in oder to shorten out your		 * code !		 * When calling this function from another app the default values will be overwritten with		 * the values you provide but if you will not provide a certain value, the default one will remain		 * Ex: If the whole app has 30 values in total (already defined by you) and you will send 10 values, 		 * those 10 values will be overwritten and the other ones kept.		 */						/**		 * these settings are for the fourth skin of the tooltip		 */		public function defaultValuesForSkin4()		{			obj = new Object();						obj.Text = "FOURTH TOOLTIP";			obj.font = "Arial";			obj.color = "0xFFFFFF";			obj.size = "10"						obj.strokeColor = 0xc8c8c8;			obj.strokeAlpha = 1;			obj.strokeWidth = 1;						obj.backgroundColor = new Array();			obj.backgroundColor.push(Number(0x70CEFF));	// light blue			obj.backgroundColor.push(Number(0x70CEFF));			obj.backgroundColor.push(Number(0x70CEFF));						obj.backgroundAlpha = 1;			obj.backgroundRadius = 0;						obj.addShadow = "false";			obj.shadowDistance = 1;			obj.shadowAngleInDegrees = 45;			obj.shadowColor = 0x000000;			obj.shadowAlpha = 0.25;			obj.shadowBlurX = 6;			obj.shadowBlurY = 6;			obj.shadowStrength = 3;			obj.shadowQuality = 3;			obj.shadowInner = false;			obj.shadowKnockout = false;			obj.shadowHideObject = false;						obj.image = "IDstar";			obj.maskSlide = "";			obj.alphaSlideStart = "0";			obj.alphaSlideStop = "1";			obj.blurXSlideStart = "0";			obj.blurYSlideStart = "100";						obj.tipOrientationY = "bottom";			obj.tipOrientationX = "left";			obj.tipWidth = 0;			obj.tipHeight = 0;			obj.tipInclination = 4;			obj.tipX = 24;							obj.xTextCorrection = 0;			obj.yTextCorrection = -1;									obj.XDistanceFromCursor = 0;			obj.YDistanceFromCursor = 24;						obj.addToTotalWidth = 4;						obj.delay = 0;			obj.animationTime = 0.0;		// was 0.3			obj.animationType = "linear";								}												/**		 * This function will be called from outside and it will show the tooltip		 * @param	myObj		 */		public function show(myObj:Object)		{			shortParse(myObj);						/*			if (myTimer) 				myTimer.stop();				startTimer();			*/						// try mouse move instead			container.stage.addEventListener(MouseEvent.MOUSE_MOVE, move, false, 0, true);						// start by calling move			move(new Event("init"));						Tweener.addTween(this, { alpha:obj.alphaSlideStop, _Blur_blurX:0, _Blur_blurY:0, delay:obj.delay, time:obj.animationTime, transition:obj.animationType } );			Tweener.addTween(tip_mask, {width:maskWO, height:maskHO, x:maskXO, y:maskYO, delay:obj.delay, time:obj.animationTime, transition:obj.animationType });		}				/**		 * This function will execute the interval used for moving the tooltip after the mouse		 */		public function startTimer()		{			myTimer = new Timer(10, 0);			myTimer.addEventListener(TimerEvent.TIMER, move);			myTimer.start();		}				/**		 * This function will execute every 10 miliseconds and this will handle the tooltip's movement		 * and the tip's movement, it will take into consideration all the cases.		 * Note that some of the tooltip's methods may not work ok when the tip is set to move according to		 * the mouse position relevant to the scene.		 * @param	aux		 */		public function move(e:Event)		{			switch(obj.tipOrientationX)			{				case "left":					this.x = Math.round(container.mouseX + obj.XDistanceFromCursor);					break;									case "right":					this.x = Math.round(container.mouseX - bgX + obj.backgroundRadius + obj.tipWidth/2 + 2);					break;									case "center":					this.x = Math.round(container.mouseX - bgX / 2);					break;			}						switch(obj.tipOrientationY)			{				case "bottom":					this.y = Math.round(container.mouseY - obj.YDistanceFromCursor);					break;									case "top":					this.y = Math.round(container.mouseY + obj.YDistanceFromCursor);					break;			}								}			/**		 * This function will hide the tooltip.		 * This must be called from an outside app		 * @param	myObj		 */		public function hide(myObj:Object)		{			/*			if (myTimer) 				myTimer.stop();			*/						container.stage.removeEventListener(MouseEvent.MOUSE_MOVE, move);						Tweener.removeTweens(this);			shortParse(myObj);			Tweener.addTween(this, { alpha:obj.alphaSlideStart, _Blur_blurX:obj.blurXSlideStart, _Blur_blurY:obj.blurYSlideStart, time:obj.animationTime, transition:obj.animationType, onComplete:moveOffscreen } );						Tweener.addTween(tip_mask, {width:maskWN, height:maskHN, x:maskXN, y:maskYN, time:obj.animationTime, transition:obj.animationType });		}				public function moveOffscreen() {			this.x = 9999;			this.y = 9999;		}						/**		 * This function will end the interval used for moving the tooltip		 * taking into consideration the mouse coordinates		 */		public function endInterval()		{			myTimer.stop();		}						/**		 * This function will build the background.		 * If you have set the tooltip's tip to move this function will be executed every 10 miliseconds		 */		private function buildBackground()		{			var alphas:Array = new Array();			var colors:Array = new Array();			var ratios:Array = new Array();			alphas = [obj.backgroundAlpha, obj.backgroundAlpha, obj.backgroundAlpha];			colors = [obj.backgroundColor[0], obj.backgroundColor[1], obj.backgroundColor[2]];			ratios = [0, 127.5, 255];				drawGradient(bg, bgX, bgY, obj.backgroundRadius, colors, alphas, ratios, 90);						/*			if(obj.addShadow == "true")				addShadow();				*/		}						/**		 * This function will add the shadow to the background		 */		 /*		private function addShadow() {				var filter:DropShadowFilter = new DropShadowFilter(obj.shadowDistance, obj.shadowAngleInDegrees, obj.shadowColor,										  obj.shadowAlpha, obj.shadowBlurX, obj.shadowBlurY, obj.shadowStrength, obj.shadowQuality, obj.shadowInner, obj.shadowKnockout, obj.shadowHideObject);			var fa:Array = new Array();			fa.push(filter);			content.filters = fa;				}		*/				/**		 * This function will parse the object and it will replace the default values		 * if existent with new ones		 * @param	myObj		 */		public function shortParse(myObj:Object)		{									with (this) {				for (var i in myObj) {					switch(i)					{						case "delay":							obj.delay = Number(myObj[i]);							break;												case "animationTime":							obj.animationTime = Number(myObj[i]);							break;													case "animationType":							obj.animationType = String(myObj[i]);							break;																	}				}			}		}				/**		 * This function will be called in the main app and it will receive		 * the object, with all the customization parameters.		 * If some of the customization parameters are not present, the default ones will be kept and		 * if necessary new ones will be created.		 * If an array of colors / sizes will not math the text's number of lines,		 * the array will be completed with the last read value		 * @param	myObj		 */		public function setCustomVars(myObj:Object)		{			parseObject(myObj);						if (obj.backgroundColor.length < 3)			{				if (obj.backgroundColor.length == 1)				{					obj.backgroundColor[1] = obj.backgroundColor[2] = obj.backgroundColor[0];				}				else				{					if (obj.backgroundColor.length == 2)					{						obj.backgroundColor[2] = obj.backgroundColor[1];					}					else					{						if (obj.backgroundColor.length == 0)						{							obj.backgroundColor[0] = obj.backgroundColor[1] = obj.backgroundColor[2] = 0xffffff;						}					}				}			}						var tf:TextField = new TextField();			tf.name = "txt";			Text.addChild(tf);						formatMyText(tf);		}		/**		 * This function will parse the text		 * and apply the text attributes		 * @param	mc		 */		private function formatMyText(mc:TextField)		{			var tempTF = new TextFormat();			tempTF.font = obj.font;			tempTF.bold = true;			tempTF.size = obj.size;			tempTF.color = obj.color;			mc.defaultTextFormat = tempTF;						mc.autoSize = TextFieldAutoSize.LEFT;			mc.wordWrap = false;			mc.selectable = false;			mc.antiAliasType = "advanced";			//mc.embedFonts = true;			mc.text = obj.Text;						// add a drop shadow filter			var dropShadow:DropShadowFilter = new DropShadowFilter();			dropShadow.distance = 5;			dropShadow.angle = 45;			dropShadow.color = 0;			dropShadow.alpha = 1;			dropShadow.blurX = 5;			dropShadow.blurY = 5;			dropShadow.strength = 1;			dropShadow.quality = 1;			mc.filters = new Array(dropShadow);						trace("mc.text = "+mc.text+", Text.width = "+Text.width+", font is "+mc.defaultTextFormat.font);						bgX = Math.round(Text.width + 3 + obj.addToTotalWidth);			bgY = Math.round(Text.height + 6);						// DON'T add the star graphic			/*			trace ("adding star graphic");			var image:MovieClip = new IDstar			graf.addChild(image);			graf.x = 4;			graf.y = Math.round(bgY / 2 - graf.height / 2);			bgX += graf.width;			*/						trace("building background");			buildBackground();						trace("positioning Text");			Text.x = Math.round(graf.width + 5 )+ obj.xTextCorrection;			Text.y = Math.round(bgY / 2 -  Text.getChildByName("txt").height / 2 + 1)+ obj.yTextCorrection;						trace("setting up tip_mask");			tip_mask.width = maskWN = bgX + 10;			tip_mask.height = maskHN = bgY + 10;			tip_mask.x = -5;			tip_mask.y = -5;						if (obj.maskSlide == "") {				maskWO = maskWN;				maskHO = maskHN; 			} 			else if (obj.maskSlide == "left-right") {				maskWO = maskWN;				tip_mask.width = maskWN = 0;				maskHO = maskHN;			} 			else if (obj.maskSlide == "right-left") {				maskWO = maskWN;				tip_mask.width = maskWN = 0;				maskHO = maskHN;				tip_mask.x = maskXN = maskWO;				maskXO = 0;			} 			else if (obj.maskSlide == "top-bottom") {				maskHO = maskHN;				maskWO = maskWN;				tip_mask.height = maskHN = 0;			} 			else if (obj.maskSlide == "bottom-top") {				maskHO = maskHN;				maskYN = tip_mask.y = maskHO;				tip_mask.height = 0;				maskYO = 0;			}									content.mask = tip_mask;						this.alpha = obj.alphaSlideStart;			setMcBlur(this, obj.blurXSlideStart, obj.blurYSlideStart, 2);					this.x = this.y = -1000;		}				// set movie clip blur (this will remove all other applyed filters)		private function setMcBlur(mc:MovieClip, blurX:Number = 0, blurY:Number = 0, quality:Number = 2) {			mc.filters = (blurX == 0 && blurY == 0) ? [] : [new BlurFilter(blurX, blurY, quality)];		}						/**		 * This function parses the whole object		 * If the value is available the default one will be overwritten		 * @param	myObj		 */		private function parseObject(myObj:Object)		{			for (var i in myObj) {				switch(i) {					case "Text":							obj.Text = String(myObj[i]);							break;											case "font":							obj.font = String(myObj[i]);							break;										case "color":							obj.color = Number(myObj[i]);							break;										case "size":							obj.size = Number(myObj[i]);							break;											case "strokeColor":													obj.strokeColor =  Number(myObj[i]);							break;											case "strokeAlpha":							obj.strokeAlpha = Number(myObj[i]);							break;											case "strokeWidth":							obj.strokeWidth = Number(myObj[i]);							break;										case "backgroundColor":						var fontStr = myObj[i];						var fontArr = fontStr.split("|");						var idx:Number;						for (idx = 0; idx < 3; idx++){							obj.backgroundColor[idx] = Number(fontArr[idx]);						}						break;											case "backgroundAlpha":							obj.backgroundAlpha = Number(myObj[i]);							break;											case "backgroundRadius":							obj.backgroundRadius = Number(myObj[i]);							break;												case "addShadow":							obj.addShadow = String(myObj[i]);							break;										case "shadowDistance":							obj.shadowDistance = Number(myObj[i]);							break;											case "shadowColor":							obj.shadowColor = Number(myObj[i]);							break;											case "shadowAlpha":							obj.shadowAlpha = Number(myObj[i]);							break;										case "shadowBlurX":							obj.shadowBlurX = Number(myObj[i]);							break;											case "shadowBlurY":							obj.shadowBlurY = Number(myObj[i]);							break;												case "shadowStrength":							obj.shadowStrength = Number(myObj[i]);							break;										case "shadowQuality":							obj.shadowQuality = Number(myObj[i]);							break;											case "shadowInner":							if(String(myObj[i])=="true")								obj.shadowInner = true;							break;											case "shadowKnockout":							if(String(myObj[i])=="true")								obj.shadowKnockout = true;							break;										case "shadowHideObject":							if(String(myObj[i])=="true")								obj.shadowHideObject = true;							break;										case "shadowAngleInDegrees":							obj.shadowAngleInDegrees = Number(myObj[i]);							break;																	case "tipOrientationY":							obj.tipOrientationY = String(myObj[i]);							break;										case "tipOrientationX":							obj.tipOrientationX = String(myObj[i]);							break;										case "tipWidth":						obj.tipWidth = Number(myObj[i]);						break;											case "tipHeight":						obj.tipHeight = Number(myObj[i]);						break;											case "tipInclination":						obj.tipInclination = Number(myObj[i]);						break;										case "XDistanceFromCursor":						obj.XDistanceFromCursor = Number(myObj[i]);						break;										case "YDistanceFromCursor":						obj.YDistanceFromCursor = Number(myObj[i]);						break;										case "image":						obj.image = String(myObj[i]);						break;											case "maskSlide":						obj.maskSlide = String(myObj[i]);						break;											case "alphaSlideStart":						obj.alphaSlideStart = Number(myObj[i]);						break;											case "alphaSlideStop":						obj.alphaSlideStop = Number(myObj[i]);						break;																	case "blurXSlideStart":						obj.blurXSlideStart = Number(myObj[i]);						break;											case "blurYSlideStart":						obj.blurYSlideStart = Number(myObj[i]);						break;																																			case "xTextCorrection":						obj.xTextCorrection = Number(myObj[i]);						break;											case "yTextCorrection":						obj.yTextCorrection = Number(myObj[i]);						break;																	case "addToTotalWidth":						obj.addToTotalWidth = Number(myObj[i]);						break;											}			}		}				/**		 * 	This function draws an gradient oval or square if r=0, radius takes values from 0--360 and it's the gradient's orientation		 *  Example:		 *  colors = [0x00ff00, 0xff0000, 0x0000ff];		 *  alphas = [100, 100, 100];		 *	ratios = [0, 127.5, 255];		 * @param	mc		 * @param	mw		 * @param	mh		 * @param	r		 * @param	colors		 * @param	alphas		 * @param	ratios		 * @param	radius		 */		private function drawGradient(clip:MovieClip, mw:Number, mh:Number, r:Number, colors:Array, alphas:Array, ratios:Array, radius:Number) {			var matrix:Matrix = new Matrix();			matrix.createGradientBox(mw, mh, (radius * Math.PI / 180), 0, 0);			var mc:Graphics = clip.graphics;			mc.clear();			mc.beginGradientFill("linear", colors, alphas, ratios, matrix);			if(obj.strokeWidth!=0)				mc.lineStyle(obj.strokeWidth, obj.strokeColor, obj.strokeAlpha, true, "none", "round");			mc.moveTo(r, 0);						if ((obj.tipWidth != 0)&&(obj.tipOrientationY=="top"))			{				if (obj.tipOrientationX == "right") {					obj.tipX = Math.round(mw - r - 2);				}								if (obj.tipOrientationX == "left") {					obj.tipX = Math.round(obj.tipWidth + r + 2);				}								if (obj.tipOrientationX == "center") {					obj.tipX = Math.round(mw/2 + obj.tipWidth/2);				}								mc.lineTo(obj.tipX-obj.tipWidth, 0);				mc.lineTo(obj.tipX-obj.tipWidth - obj.tipInclination, -obj.tipHeight);				mc.lineTo(obj.tipX, 0);			}						mc.lineTo(mw-r,0);			mc.curveTo(mw,0,mw,r);			mc.lineTo(mw,mh-r);			mc.curveTo(mw, mh, mw - r, mh);						if ((obj.tipWidth != 0)&&(obj.tipOrientationY=="bottom"))			{				if (obj.tipOrientationX == "right") {					obj.tipX = Math.round(mw - r - 2);				}								if (obj.tipOrientationX == "left") {					obj.tipX = Math.round(obj.tipWidth + r + 2);				}								if (obj.tipOrientationX == "center") {					obj.tipX = Math.round(mw/2 + obj.tipWidth/2);				}								mc.lineTo(obj.tipX, mh);				mc.lineTo(obj.tipX+obj.tipInclination, mh+obj.tipHeight);				mc.lineTo(obj.tipX-obj.tipWidth, mh);			}						mc.lineTo(r,mh);			mc.curveTo(0,mh,0,mh-r)			mc.lineTo(0,r);			mc.curveTo(0,0,r,0);			mc.endFill();		}								}	}	/**		 * This function draws an oval or square if r=0		 * @param	mc		 * @param	mw		 * @param	mh		 * @param	r		 * @param	fillColor		 * @param	alphaAmount		 */		 /*		private function drawOval(mc:MovieClip, mw:Number, mh:Number, r:Number, fillColor:Number, alphaAmount:Number) {			mc.clear();			mc.beginFill(fillColor,alphaAmount);			mc.moveTo(r,0);			mc.lineTo(mw-r,0);			mc.curveTo(mw,0,mw,r);			mc.lineTo(mw,mh-r);			mc.curveTo(mw,mh,mw-r,mh);			mc.lineTo(r,mh);			mc.curveTo(0,mh,0,mh-r)			mc.lineTo(0,r);			mc.curveTo(0,0,r,0);			mc.endFill();		}		*/		/**	 * Settings you should use, if you want only in your code	 */			/*		 myTooltip1.setCustomVars({Text:"THIS IS THE FIRST TOOLTIP",							 font:"CuprumFFU",							 color:"0xfcffcf",							 size:"11",												 strokeColor:"0x414141",							 strokeAlpha:100,							 strokeWidth:0,													 backgroundColor:"0xb5bc00|0x9ca500|0x859000",							 backgroundAlpha:100,							 backgroundRadius:0,												addShadow:"true",							shadowAngleInDegrees:45,							shadowDistance:1,							shadowColor:"0x000000",							shadowAlpha:"0.25",							shadowBlurX:"6",							shadowBlurY:"6",							shadowStrength:"3",							shadowQuality:"3",														image:"IDarrow",							maskSlide:"left-right",							alphaSlideStart:"100",							alphaSlideStop:"100",							blurXSlideStart:"0",							blurYSlideStart:"0",														xTextCorrection:0,							yTextCorrection:0,							addToTotalWidth:0,														tipOrientationY:"bottom", //top, bottom							tipOrientationX:"left", //left / center / right							tipWidth:0,							tipHeight:0,							tipInclination:-8,														XDistanceFromCursor:-14,							YDistanceFromCursor:30				});	*/